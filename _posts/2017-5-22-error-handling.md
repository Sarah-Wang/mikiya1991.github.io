---
title: 关于错误处理的思考
comments: true
layout: markdown
keyword: error, handle, goto, try, catch, errno, return
---

# 关于错误处理的思考

--------------------------------------

## 返回值

最基本的错误处理方式，就如同标准C库中所讲，使用return返回值和设置全局变量errno搭配的方式，将程序或者函数中的错误报告给上层。

unix中的函数返回值，大多遵循如下的约定 

1. int类型的返回值 **0一般代表成功，正值代表成功并返回数据， -1代表失败**
2. 指针类型的返回值 **成功返回指针， 错误返回NULL**
3. 可能置错误号errno &lt errno.h &gt
4. 具体返回值跟具体函数相关

例如：&lt;unstd.h&gt;中的 

	ssize_t read(int fd, void *buf, size_t nbytes)函数

* read成功返回read的字节数
* read读到文件尾， 返回0 (可理解为整个读文件操作成功)
* 失败、错误返回 -1， 错误号写在errno中

错误可分为致命错误和非致命错误。对于这两类错误，典型的处理方式是：
* 非致命错误 -&gt; 延迟重试
* 致命错误 -&gt; 上报给上层或打印错误， 退出

<br/>

## 错误的集中处理

一般函数出现了错误，我们直接return返回错误类型就行了。

但是在复杂功能函数中，会涉及到资源申请释放、出错log记录等等操作，如果每次出错都进行一次释放和记录，代码会冗余并且逻辑混乱。
因此比较好的方式自然是 **错误的集中处理**。

<br/>

#### goto (局部的集中错误处理)
在C中常用`goto`进行这种操作。将错误记录在错误号ret中，然后goto到函数尾， 根据错误号，释放资源、打印错误信息，退出。
这种方式代码逻辑更好，也不会出现过多的冗余。

<br/>

#### try-catch (全局的集中错误处理)
在面向对象的语言中，存在一个更好的选择`try - catch`语句。 try块中，不用管理错误，直接进行流程控制； 将错误处理集中放到catch块中。

try-catch有一个goto语句无法做到的优点，它的集中处理可以跨越语句段， C中的每个函数都必须进行错误处理， 但是C++中的这种错误处理完全可以跨越函数。
单个函数可能没有必要处理错误，某类型的错误，完全交给上层捕捉，集中处理。

我们可以在try块中，无限制的进行操作，调用各种函数，它们也不需要每个都关注某种错误。 而一旦出错，会被上层catch块捕捉，然后处理。

<br/>

## 函数操作的原子性

常常我们写某个函数的过程中，会申请很多个资源，然后利用这些资源进行操作。然而可能在运行的过程中，发生了错误，必须要释放掉申请的资源。

问题来了，对于这些资源，**包括自己申请的、上层传过来的、第三方函数生成的**，我是不是应该都释放掉呢？还是只释放一部分。  

- 这里就要保证函数操作的原子性，**所有的操作在其它人看来必须是一个操作，而不是可能存在很多结果**  
- 出错了就要清理现场退出，而不要把要不要清理的决定交给上层  
- 就算可能这个函数包含**很多个资源申请释放，在上层看来也必须是一个**   
- 甚至在多进程的环境中，函数也要保证自己多个行为是一个行为，而不会相互影响(加锁)   



